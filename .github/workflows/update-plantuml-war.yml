name: Safe Update PlantUML Server WAR (GitHub Status) for PUML-Server-Deployer branch

on:
  workflow_dispatch: # Allows manual triggering via CLI or UI

permissions:
  contents: write
  deployments: read # Required to read the deployment status
  actions: write    # Required to disable workflow on failure

jobs:
  update-branch:
    runs-on: ubuntu-latest
    env:
      DEPLOY_ENV: "puml-server" # Heroku Environment Name
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          # No 'ref' needed; defaults to the current branch (PUML-Server-Deployer)

      - name: Check for Updates
        id: check
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # 1. Target the 'plantuml-server' repo
          TAG=$(gh release view --repo plantuml/plantuml-server --json tagName --jq .tagName)
          
          # 2. Construct Filename
          # URL format: .../v1.2025.10/plantuml-v1.2025.10.war
          WAR_NAME="plantuml-${TAG}.war"
          DOWNLOAD_URL="https://github.com/plantuml/plantuml-server/releases/download/${TAG}/${WAR_NAME}"
          
          if [ -f "$WAR_NAME" ]; then
            echo "Branch is already on version $TAG"
            echo "update_needed=false" >> $GITHUB_OUTPUT
          else
            echo "New version found: $TAG"
            echo "update_needed=true" >> $GITHUB_OUTPUT
            echo "war_name=$WAR_NAME" >> $GITHUB_OUTPUT
            echo "download_url=$DOWNLOAD_URL" >> $GITHUB_OUTPUT
          fi

      - name: Download New War
        if: steps.check.outputs.update_needed == 'true'
        run: |
          curl -L -o "${{ steps.check.outputs.war_name }}" "${{ steps.check.outputs.download_url }}"
          
          # Verify file integrity (basic check)
          if ! file "${{ steps.check.outputs.war_name }}" | grep -q "Zip archive data"; then
            echo "Error: Downloaded file is corrupt or not a valid WAR archive."
            exit 1
          fi

      - name: Stage 1 - Push New Version (Keep Old War)
        if: steps.check.outputs.update_needed == 'true'
        id: deploy_stage
        run: |
          WAR_NAME="${{ steps.check.outputs.war_name }}"
          
          git config user.name "Update Bot"
          git config user.email "bot@users.noreply.github.com"
          
          # Update Procfile to point to the new WAR
          # Regex matches 'plantuml-*.war' to handle variable version strings
          sed -i "s/plantuml-.*\.war/$WAR_NAME/" Procfile
          
          # Add new files (Old WAR remains in repo for safety during deployment)
          git add "$WAR_NAME" Procfile
          git commit -m "Deploy: Update to $WAR_NAME"
          
          # Push to the current branch
          git push origin HEAD
          
          # Output Commit SHA to track the deployment status
          echo "commit_sha=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT

      - name: Monitor GitHub Deployment Status
        if: steps.check.outputs.update_needed == 'true'
        id: monitor
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          COMMIT_SHA: ${{ steps.deploy_stage.outputs.commit_sha }}
          REPO: ${{ github.repository }}
        run: |
          echo "Waiting for GitHub Deployment Status for commit $COMMIT_SHA in env '$DEPLOY_ENV'..."
          
          # Loop for 5 minutes (30 checks * 10 seconds)
          for i in {1..30}; do
            sleep 10
            
            # 1. Find the Deployment ID associated with this Commit SHA and Environment
            DEPLOYMENTS=$(gh api "repos/$REPO/deployments?sha=$COMMIT_SHA&environment=$DEPLOY_ENV")
            DEP_ID=$(echo "$DEPLOYMENTS" | jq -r '.[0].id // empty')
            
            if [ -z "$DEP_ID" ]; then
              echo "Attempt $i: Deployment not created yet by Heroku..."
              continue
            fi
            
            # 2. Get the STATUS of that Deployment
            STATUSES=$(gh api "repos/$REPO/deployments/$DEP_ID/statuses")
            STATE=$(echo "$STATUSES" | jq -r '.[0].state // "pending"')
            
            echo "Attempt $i: Deployment ID $DEP_ID state is '$STATE'"
            
            if [ "$STATE" == "success" ]; then
              echo "Deployment Successful!"
              echo "result=success" >> $GITHUB_OUTPUT
              exit 0
            elif [ "$STATE" == "failure" ] || [ "$STATE" == "error" ]; then
              echo "Deployment Failed!"
              echo "result=failure" >> $GITHUB_OUTPUT
              exit 0
            fi
          done
          
          echo "Timeout waiting for deployment status."
          echo "result=timeout" >> $GITHUB_OUTPUT

      - name: Stage 2 - Cleanup Old War (Only if Green)
        if: steps.monitor.outputs.result == 'success'
        run: |
          NEW_WAR="${{ steps.check.outputs.war_name }}"
          
          # Delete any plantuml WAR that is NOT the new one
          find . -maxdepth 1 -name "plantuml-*.war" ! -name "$NEW_WAR" -delete
          
          git config user.name "Update Bot"
          git config user.email "bot@users.noreply.github.com"
          
          git add .
          if ! git diff --staged --quiet; then
            git commit -m "Cleanup: Removed old WARs"
            git push origin HEAD
          fi

      - name: Rollback (If Red/Timeout)
        if: contains(fromJson('["failure", "timeout"]'), steps.monitor.outputs.result)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Deployment failed. Rolling back..."
          
          git config user.name "Update Bot"
          git config user.email "bot@users.noreply.github.com"
          
          # Revert changes to restore old Procfile and old WAR
          git revert --no-edit ${{ steps.deploy_stage.outputs.commit_sha }}
          git push origin HEAD
          
          echo "Rolled back. Disabling workflow..."
          gh workflow disable "Manual Update PlantUML (Branch)"
          exit 1
