name: Safe Update PlantUML Server WAR (GitHub Status)

on:
  workflow_dispatch:

permissions:
  contents: write
  deployments: read
  actions: write

jobs:
  update-branch:
    runs-on: ubuntu-latest
    env:
      DEPLOY_ENV: "puml-server"
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check for Updates and Get Asset URL
        id: check
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Fetching latest release info from plantuml/plantuml-server..."
          
          # 1. Get the Release Data (Tag and Assets)
          # We fetch the assets list to find the exact URL, avoiding manual construction errors.
          RELEASE_JSON=$(gh release view --repo plantuml/plantuml-server --json tagName,assets)
          
          TAG=$(echo "$RELEASE_JSON" | jq -r .tagName)
          echo "Latest Tag found: $TAG"
          
          # 2. Find the specific WAR file URL
          # We look for a file that looks like 'plantuml-v1.23.war' 
          # We exclude 'jre8' or 'jsp' variants based on your screenshot preference.
          DOWNLOAD_URL=$(echo "$RELEASE_JSON" | jq -r '.assets[] | select(.name | test("^plantuml-v[0-9.]+\\.war$")) | .url')
          
          # 3. Extract Filename from URL
          WAR_NAME=$(basename "$DOWNLOAD_URL")
          
          echo "Found Asset: $WAR_NAME"
          echo "Download URL: $DOWNLOAD_URL"
          
          if [ -z "$DOWNLOAD_URL" ] || [ "$DOWNLOAD_URL" == "null" ]; then
             echo "Error: Could not find a matching WAR file in the assets list."
             echo "Available assets:"
             echo "$RELEASE_JSON" | jq -r '.assets[].name'
             exit 1
          fi

          # 4. Check if we already have it
          if [ -f "$WAR_NAME" ]; then
            echo "Branch is already on version $TAG ($WAR_NAME)"
            echo "update_needed=false" >> $GITHUB_OUTPUT
          else
            echo "New version detected."
            echo "update_needed=true" >> $GITHUB_OUTPUT
            echo "war_name=$WAR_NAME" >> $GITHUB_OUTPUT
            echo "download_url=$DOWNLOAD_URL" >> $GITHUB_OUTPUT
          fi

      - name: Download New War
        if: steps.check.outputs.update_needed == 'true'
        run: |
          URL="${{ steps.check.outputs.download_url }}"
          FILE="${{ steps.check.outputs.war_name }}"
          
          echo "Downloading $FILE from $URL..."
          
          # -f: Fail silently (no output at all) on server errors (404, 500)
          # -L: Follow redirects
          # -o: Output file
          curl -fL -o "$FILE" "$URL"
          
          # Verify integrity
          echo "Verifying file structure..."
          if ! file "$FILE" | grep -q "Zip archive data"; then
            echo "Error: Downloaded file is corrupt or not a valid WAR archive."
            # Print file type to see what we actually got (e.g., HTML error page)
            file "$FILE"
            exit 1
          fi
          echo "File verification passed."

      - name: Stage 1 - Push New Version (Keep Old War)
        if: steps.check.outputs.update_needed == 'true'
        id: deploy_stage
        run: |
          WAR_NAME="${{ steps.check.outputs.war_name }}"
          
          git config user.name "Update Bot"
          git config user.email "bot@users.noreply.github.com"
          
          # Update Procfile regex to be safe
          sed -i "s/plantuml-.*\.war/$WAR_NAME/" Procfile
          
          git add "$WAR_NAME" Procfile
          git commit -m "Deploy: Update to $WAR_NAME"
          
          # Push to current branch
          git push origin HEAD
          
          echo "commit_sha=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT

      - name: Monitor GitHub Deployment Status
        if: steps.check.outputs.update_needed == 'true'
        id: monitor
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          COMMIT_SHA: ${{ steps.deploy_stage.outputs.commit_sha }}
          REPO: ${{ github.repository }}
        run: |
          echo "Waiting for GitHub Deployment Status for commit $COMMIT_SHA in env '$DEPLOY_ENV'..."
          
          # Loop for 5 minutes
          for i in {1..30}; do
            sleep 10
            
            DEPLOYMENTS=$(gh api "repos/$REPO/deployments?sha=$COMMIT_SHA&environment=$DEPLOY_ENV")
            DEP_ID=$(echo "$DEPLOYMENTS" | jq -r '.[0].id // empty')
            
            if [ -z "$DEP_ID" ]; then
              echo "Attempt $i: Waiting for Heroku to report deployment..."
              continue
            fi
            
            STATUSES=$(gh api "repos/$REPO/deployments/$DEP_ID/statuses")
            STATE=$(echo "$STATUSES" | jq -r '.[0].state // "pending"')
            
            echo "Attempt $i: Status is '$STATE'"
            
            if [ "$STATE" == "success" ]; then
              echo "result=success" >> $GITHUB_OUTPUT
              exit 0
            elif [ "$STATE" == "failure" ] || [ "$STATE" == "error" ]; then
              echo "result=failure" >> $GITHUB_OUTPUT
              exit 0
            fi
          done
          
          echo "result=timeout" >> $GITHUB_OUTPUT

      - name: Stage 2 - Cleanup Old War (Only if Green)
        if: steps.monitor.outputs.result == 'success'
        run: |
          NEW_WAR="${{ steps.check.outputs.war_name }}"
          
          # Delete old wars
          find . -maxdepth 1 -name "plantuml-*.war" ! -name "$NEW_WAR" -delete
          
          git config user.name "Update Bot"
          git config user.email "bot@users.noreply.github.com"
          
          git add .
          if ! git diff --staged --quiet; then
            git commit -m "Cleanup: Removed old WARs"
            git push origin HEAD
          fi

      - name: Rollback (If Red/Timeout)
        if: contains(fromJson('["failure", "timeout"]'), steps.monitor.outputs.result)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Deployment failed. Rolling back..."
          
          git config user.name "Update Bot"
          git config user.email "bot@users.noreply.github.com"
          
          git revert --no-edit ${{ steps.deploy_stage.outputs.commit_sha }}
          git push origin HEAD
          
          echo "Disabling workflow..."
          gh workflow disable "update-plantuml-war.yml"
          exit 1
