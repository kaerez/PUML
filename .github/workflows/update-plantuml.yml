name: Safe Update PlantUML (GitHub Status)

on:
  #schedule:
  #  - cron: '0 4 * * *' # Daily at 4am
  workflow_dispatch:

permissions:
  contents: write
  deployments: read # Required to read the deployment status
  actions: write    # Required to disable workflow on failure

jobs:
  update-and-verify:
    runs-on: ubuntu-latest
    env:
      DEPLOY_ENV: "puml" # GH Action Heroku Deploy Environment name
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check for Updates
        id: check
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG=$(gh release view --repo plantuml/plantuml --json tagName --jq .tagName)
          VERSION=${TAG#v}
          JAR_NAME="plantuml-${VERSION}.jar"
          DOWNLOAD_URL="https://github.com/plantuml/plantuml/releases/download/${TAG}/${JAR_NAME}"
          
          if [ -f "$JAR_NAME" ]; then
            echo "Already on latest version."
            echo "update_needed=false" >> $GITHUB_OUTPUT
          else
            echo "New version found: $VERSION"
            echo "update_needed=true" >> $GITHUB_OUTPUT
            echo "jar_name=$JAR_NAME" >> $GITHUB_OUTPUT
            echo "download_url=$DOWNLOAD_URL" >> $GITHUB_OUTPUT
          fi

      - name: Download New Jar
        if: steps.check.outputs.update_needed == 'true'
        run: |
          curl -L -o "${{ steps.check.outputs.jar_name }}" "${{ steps.check.outputs.download_url }}"
          
          # Verify it's a valid zip/jar file
          if ! file "${{ steps.check.outputs.jar_name }}" | grep -q "Zip archive data"; then
            echo "Error: Corrupt file."
            exit 1
          fi

      - name: Stage 1 - Push New Version (Keep Old Jar)
        if: steps.check.outputs.update_needed == 'true'
        id: deploy_stage
        run: |
          JAR_NAME="${{ steps.check.outputs.jar_name }}"
          
          git config user.name "Update Bot"
          git config user.email "bot@users.noreply.github.com"
          
          # Update Procfile
          sed -i "s/plantuml-[0-9.]*\.jar/$JAR_NAME/" Procfile
          
          # Add new files (Old JAR remains in repo for safety)
          git add "$JAR_NAME" Procfile
          git commit -m "Deploy: Update to $JAR_NAME"
          git push origin main
          
          # Output Commit SHA to track the deployment status
          echo "commit_sha=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT

      - name: Monitor GitHub Deployment Status
        if: steps.check.outputs.update_needed == 'true'
        id: monitor
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          COMMIT_SHA: ${{ steps.deploy_stage.outputs.commit_sha }}
          REPO: ${{ github.repository }}
        run: |
          echo "Waiting for GitHub Deployment Status for commit $COMMIT_SHA in env '$DEPLOY_ENV'..."
          
          # We loop for 5 minutes (30 checks * 10 seconds)
          for i in {1..30}; do
            sleep 10
            
            # 1. Find the Deployment ID associated with this Commit SHA and Environment
            # We filter by 'sha' and 'environment' to match exactly what is in your screenshot
            DEPLOYMENTS=$(gh api "repos/$REPO/deployments?sha=$COMMIT_SHA&environment=$DEPLOY_ENV")
            DEP_ID=$(echo "$DEPLOYMENTS" | jq -r '.[0].id // empty')
            
            if [ -z "$DEP_ID" ]; then
              echo "Attempt $i: Deployment not created yet by Heroku..."
              continue
            fi
            
            # 2. Get the STATUS of that Deployment (success, failure, etc.)
            STATUSES=$(gh api "repos/$REPO/deployments/$DEP_ID/statuses")
            STATE=$(echo "$STATUSES" | jq -r '.[0].state // "pending"')
            
            echo "Attempt $i: Deployment ID $DEP_ID state is '$STATE'"
            
            if [ "$STATE" == "success" ]; then
              echo "Deployment Successful!"
              echo "result=success" >> $GITHUB_OUTPUT
              exit 0
            elif [ "$STATE" == "failure" ] || [ "$STATE" == "error" ]; then
              echo "Deployment Failed!"
              echo "result=failure" >> $GITHUB_OUTPUT
              exit 0
            fi
            # If pending/in_progress, we loop again
          done
          
          echo "Timeout waiting for deployment status."
          echo "result=timeout" >> $GITHUB_OUTPUT

      - name: Stage 2 - Cleanup Old Jar (Only if Green)
        if: steps.monitor.outputs.result == 'success'
        run: |
          NEW_JAR="${{ steps.check.outputs.jar_name }}"
          
          # Delete old jars
          find . -maxdepth 1 -name "plantuml-*.jar" ! -name "$NEW_JAR" -delete
          
          git config user.name "Update Bot"
          git config user.email "bot@users.noreply.github.com"
          
          git add .
          if ! git diff --staged --quiet; then
            git commit -m "Cleanup: Removed old JARs"
            git push origin main
          fi

      - name: Rollback (If Red/Timeout)
        if: contains(fromJson('["failure", "timeout"]'), steps.monitor.outputs.result)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Deployment failed. Rolling back..."
          
          git config user.name "Update Bot"
          git config user.email "bot@users.noreply.github.com"
          
          # Revert changes to restore old Procfile and old JAR
          git revert --no-edit ${{ steps.deploy_stage.outputs.commit_sha }}
          git push origin main
          
          echo "Rolled back. Disabling workflow..."
          gh workflow disable "Safe Update PlantUML (GitHub Status)"
          exit 1
